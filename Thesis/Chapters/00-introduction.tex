% !TeX root = ../main.tex
% !TeX spellcheck = en_US

\chapter{Introduction}
Algorithms are usually developed conceptually first, their properties proven on paper and then implemented in code.

However, a lot of the assumptions and guarantees of these proofs are omitted in code and a careless implementation may diverge from these assumptions, losing the guarantees and becoming incorrect.

There has been a push towards embedding these conditions inside the program instead so that they are automatically verified when the code is compiled. On the one hand, we have tests, which ensure that an algorithm is well-behaved on some predetermined inputs. On the other hand, we have types, which aim at making certain classes of incorrect behavior impossible to express in code in the first place.

Of particular interest to the type side are resource constraints. This is a broad class of guarantees concerning limited computationally relevant resources. On the one hand this includes bounds such as limiting the number of locks held by a program, showing that there is a limit on the maximum number of concurrently open sockets or proving that network traffic stays within a quota. On the other hand this includes less immediately measurable bounds such as constraints on the amount of memory used by the program, the energy consumption of an embedded process, and the topic this thesis is concerned with: bounds on the running time of algorithms.

There have been previous attempts at developing frameworks to prove certain upper bounds on running time (eg. \cite{danielsson:2008:time-complexity-analysis}, \cite{nipkow:2017:verified-root-balanced-trees}). However these approaches are usually not correct by necessity, relying on the programmer to correctly indicate where a time step should be counted. Instead what we would like is for any program expressible in our framework to take at most as many steps (asymptotically) as indicated by the type bound.

Van Laarhoven has a promising approach based on hiding the implementation of comparison from the algorithm and using the number of these comparisons as a measure of runtime \cite{laarhoven:2013:correctness-sorting}. We will expand on this approach and show that it is feasible to implement a wide range of algorithms in this framework.