% !TeX root = ../main.tex
% !TeX spellcheck = en_US

\chapter{Conclusion}
In the Case Studies chapter, we have shown how to use our run time monad. It does carry overhead with it - both during execution and on the syntactic level. On the plus side, the syntactic overhead usually pulls double duty: Properties we need to prove for our run time are usually other correctness properties of our algorithm. Consider for example that for the order statistic selection, a significant part of the proof burden was to show the bounds of the Split's smaller and larger sets.

Ours is not the only approach to resource constraints. Memory usage, for example, is similarly "outside the model" as run time is. ... \todo{cite} has done work in this direction. Other resources are often easier to inspect, such as concurrency limits or network load, but no less important.

Real-time and embedded systems are an obvious candidate for resource verification. However for the degree of accuracy needed for these systems we would need to descend an abstraction level from "number of comparisons" to a more direct representation of time elapsed. An added hurdle is of course that Haskell, and by extension Agda, are not usually first-choice languages for real-time systems. And finally, we are unable to measure the overhead added by the framework within the framework. External analyses may be more appropriate for this.

There are two obvious avenues to continue the work presented in this thesis: Firstly, extending the framework with additional transformation and proof functions that make working with it more seamless. This might include new definitions of \texttt{\_>>=\_} and \texttt{\_*\_}: The former introduces a trailing $0$ in the run time bound when the final statement of a do-block is a \texttt{return}, the latter introduces a trailing $0$ when the first factor of a multiplication is a constant.

Secondly, reducing the run time overhead of the framework, for example by judicious use of proof elimination. Given the blurred line of compile- and run-time in dependently typed language, this goes hand in hand with increasing type checking responsiveness.